ğŸ§  Resumen de Multiprocessing en Python
ğŸŸ¢ a) Fundamentos de procesos y programaciÃ³n concurrente
ğŸ”‘ Conceptos:
Proceso: Unidad de ejecuciÃ³n con su propia memoria.

Hilo (thread): Unidad mÃ¡s liviana, comparte memoria con su proceso.

GIL (Global Interpreter Lock): En CPython, evita ejecuciÃ³n paralela de hilos â†’ por eso usamos procesos para paralelismo real.

ğŸŸ¡ b) CreaciÃ³n y gestiÃ³n de procesos
ğŸ§© Comandos y funciones clave:
Comando	Â¿QuÃ© hace?
from multiprocessing import Process	Importa la clase Process
p = Process(target=func, args=(...))	Crea un proceso para ejecutar func()
p.start()	Inicia el proceso
p.join()	Espera a que el proceso termine
p.is_alive()	Verifica si el proceso aÃºn se estÃ¡ ejecutando
p.pid	Devuelve el PID del proceso

ğŸŸ  c) ComunicaciÃ³n entre procesos
ğŸ“¬ Pipes:
Comando	Â¿QuÃ© hace?
conn1, conn2 = Pipe()	Crea un canal de comunicaciÃ³n bidireccional
conn1.send(valor)	EnvÃ­a datos
conn2.recv()	Recibe datos

ğŸ“¦ Queues:
Comando	Â¿QuÃ© hace?
cola = Queue()	Crea una cola segura para mÃºltiples procesos
cola.put(valor)	EnvÃ­a datos a la cola
cola.get()	Recibe datos de la cola

ğŸ” Diferencias:
CaracterÃ­stica	Pipe	Queue
DirecciÃ³n	Bidireccional	Unidireccional (FIFO)
NÂº de procesos	Solo entre 2	Varios procesos
Seguridad	No sincronizado	Sincronizado automÃ¡ticamente

ğŸ”´ d) SincronizaciÃ³n bÃ¡sica con Lock
ğŸ§± Comandos clave:
Comando	Â¿QuÃ© hace?
lock = Lock()	Crea un candado para sincronizar
lock.acquire()	Entra a la secciÃ³n crÃ­tica
lock.release()	Sale de la secciÃ³n crÃ­tica
with lock:	Contexto seguro para secciones crÃ­ticas

ğŸ§  Â¿Por quÃ©?
Evita condiciones de carrera cuando varios procesos acceden/modifican un mismo recurso.

ğŸ”µ e) Pool de procesos
ğŸŒŠ Comandos y mÃ©todos:
Comando / MÃ©todo	Â¿QuÃ© hace?
from multiprocessing import Pool	Importa Pool
with Pool(n) as p:	Crea un grupo de n procesos
p.map(func, lista)	Ejecuta func sobre cada Ã­tem (bloqueante)
p.apply(func, args=(...))	Llama a func (bloqueante)
p.apply_async(func, args=(...))	Llama a func (no bloqueante)
p.map_async(func, lista)	Ejecuta como map pero no bloqueante

ğŸŸ£ f) Memoria compartida bÃ¡sica (Value y Array)
ğŸ§¬ Comandos clave:
Comando	Â¿QuÃ© hace?
from multiprocessing import Value, Array	Importa estructuras compartidas
valor = Value('i', 0)	Variable entera compartida
lista = Array('i', [1,2,3])	Lista de enteros compartida
valor.value	Accede al valor actual
lista[i]	Accede o modifica un Ã­ndice

âœ… Recomendaciones finales
Siempre usÃ¡ join() para evitar procesos huÃ©rfanos.

PreferÃ­ Queue para mÃºltiples procesos y Pipe solo entre dos.

UsÃ¡ Lock si accedÃ©s a variables compartidas para evitar errores.

Pool es ideal para procesamiento paralelo de listas de tareas.

Value y Array te permiten compartir datos entre procesos, pero siempre con cuidado.
